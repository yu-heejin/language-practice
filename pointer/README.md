## 포인터 기초

- 포인터는 참조하는 타입 정보를 가지고 주소를 저장하는 객체
- 객체들은 메모리 상에 어떤 식으로 저장되고 해석되어야 할 지 결정하는 타입 정보를 갖는다.
    - 프로그램에서 다루는 데이터들은 결국 메모리에 이진수로 나열되어 있을 뿐이고, 이들을 나눠서 특정한 방식으로 해석해 사용하는 것이다.
- 이러한 객체들은 메모리의 어느 위치에 저장되어 있는지 판단하기 위한 주소를 갖는다.
    - 만약 주소가 없다면 변수 a를 메모리에서 찾으려고 할 때 a가 어디에 저장되어 있는지 알 수 없을 것이다.

## 포인터 선언하기

```c
type-qualifier_opt type_specifier * type-qualifier_opt identifier;

int *p;
unsigned char *q;
double *r;
```

- 포인터는 0x1000번지와 같은 메모리의 주소 값을 저장하는 객체이다.
    - 하지만 주소 값만으로는 의미가 없으니 해당 주소에 있는 내용을 어떻게 해석할지에 대한 타입 정보를 갖는다.
    - 이를 참조 타입(referenced type)이라고 한다.
- 위와 같이 선언된 p를 포인터 혹은 포인터 객체라고 한다.
    - 해당 경우에는 객체가 변수이므로 포인터 변수라고도 한다.
- 포인터 p에는 주소값을 저장할 수 있고, int 타입을 참조 타입으로 갖는다.
- 모든 타입이 참조 타입이 될 수 있으며, 포인터 타입 또한 참조 타입이 될 수 있다.
- 아래 선언들은 모두 동일한 선언이다.
    
    ```c
    int*p;      // 1번
    **int *p;     // 2번
    int* p;     // 3번
    int * p;    // 4번**
    int    *
    p;          // 5번
    ```
    
    - 일반적으로 C언어에서는 2번, C++언어에서는 3번을 사용한다.

```c
int* a, b;
```

- 위 선언의 경우 a와 b 모두 포인터처럼 보이지만, a만 포인터고 b는 평범한 int 타입 변수이다.

## 주소 연산과 간접 접근 연산

- 주소 연산자는 `&`, 간접 접근 연산자는 `*` 를 사용한다.

### 주소 연산자

- 주소 연산자 &는 피연산자의 주소 값을 결과로 반환한다.
- 아래와 같이 선언하면 변수 a의 주소를 구할 수 있다.
    
    ```c
    int a;      // 변수 a 선언
    printf("%p\n", &a);     // 변수 a의 주소를 출력함
    ```
    
- 주소 연산자의 피연산자가 T타입이라면, 그 결과 타입은 T 포인터이다.
    - 위 예시에서 `&a`의 결과는 변수 `a`가 저장된 주소이며, 결과 타입은 int 포인터이다.

![image](https://github.com/yu-heejin/language-practice/assets/96467030/2dac753c-16e6-4477-96d2-eb14ffbc48ef)

- 이처럼 포인터가 특정한 객체를 가리키는 경우에도 참조한다고도 이야기한다.
    - 위 상황은 포인터 p가 변수 a를 가리킨다고 하거나 참조한다고 한다.

```c
int a = 1;
int *p = &a;       // p가 a를 가리킴/참조함
```

- 포인터는 위와 같이 초기화를 동반할 수 있다.

### 간접 접근 연산자

- 간접 접근 연산자 `*`는 피연산자에 간접적으로 접근한다.
    - 참조하는 객체에 접근한다고 생각하면 된다.
- 피연산자로는 포인터 타입만 올 수 있다.
- 피연산자가 T 포인터 타입이라면, 연산 결과는 T 타입이다.

![image](https://github.com/yu-heejin/language-practice/assets/96467030/09403979-e89b-47a7-ad57-7e635b134841)

- 간접 접근 연산자의 결과는 참조하는 객체에 대한 별칭이 된다.
    - 위 예시에서 `*p`는 `a`와 동등해진다.
    - 다시 말해 `*p = 3`이라는 식은 참조하는 객체 `a`의 값을 실제로 변경시킨다.
    - `*p`가 `a`의 별칭처럼 동작하게 된다.

<aside>
❓ 접근 연산자가 아니라 간접 접근 연산자인 이유?

</aside>

```c
int a = 1;      // 변수 a가 0x1000 번지에 할당되었다고 가정
int *p = &a;    // 포인터 변수 p가 0x1004 번지에 할당되었다고 가정

a + 3;      // a에 접근하여 저장되어 있던 값을 읽음 (read)
a = 3;      // a에 접근하여 새로운 값을 저장 (modify)
```

- 접근한다는 것은 객체에 있는 값을 읽거나 새로운 값으로 수정하는 것을 의미한다.
    - 객체에 접근하기 위해서는 **객체가 저장된 메모리 주소를 찾아가서 지정된 타입에 맞춰 해석해야 한다.**
- `a + 3`은 객체 a가 저장되어 있던 주소(0x1000)에 접근해 int 타입에 맞춰 저장되어 있던 값을 읽는다.
    - 그 결과 1이라는 값을 얻고, 최종적으로 1+3을 수행해 4라는 결과를 만들어낸다.
- `a = 3`은 객체 a가 저장되어 있던 주소(0x1000번지)에 접근해 int 타입에 맞춰 새로운 값 3을 저장한다.

```c
int a = 1;      // 변수 a가 0x1000 번지에 할당되었다고 가정
int *p = &a;    // 포인터 변수 p가 0x1004 번지에 할당되었다고 가정 

*p + 3;     // a에 간접 접근하여 저장되어 있던 값을 읽음 (read)
*p = 3;     // a에 간접 접근하여 새로운 값을 저장 (modify)
```

- 포인터 객체도 접근해 그 값을 읽어야한다.
- 포인터 객체 내에는 주소 값이 저장되어 있으며, 간접 접근 시 해당 주소를 찾아간다.
    - 찾아간 주소를 참조하고 있는 타입에 맞춰 해석해 사용하는 것이다.
- `*p + 3`은 우선 포인터 객체가 저장되어 있던 주소(0x1004)에 접근해 그 값을 읽는다.
    - 읽은 값(0x1000)을 주소로 해석하고, 다시 해당 주소로 접근해 참조하고 있는 int 타입에 맞춰 저장되어 있는 값을 읽는다.
    - 그 결과 1이라는 값을 얻고, 최종적으로 1 + 3을 수행한다.
- `*p = 3`도 우선 포인터 객체가 저장되어 있던 주소(0x1004)에 접근해 그 값을 읽는다.
    - 읽은 값을 주소로 해석하고, 다시 해당 주소로 접근해 참조하고 있는 int타입에 맞춰 새로운 값 3을 저장한다.
    - 그 결과 변수 a의 값은 3으로 수정된다.
- 이처럼 간접 접근의 결과는 참조하고 있던 객체와 동등하지만 동일하게 동작하지 않는다.
    - **참조하고 있던 객체에 접근하기 위해 포인터 객체를 한번 거쳐서 접근하므로 간접 접근**이라고 부른다.
    - 간접 접근을 참조의 반대라고 하여 역참조(dereference)라고도 한다.

<aside>
❓ 만약 유효하지 않은 값을 참조하는 포인터에 대해 간접 접근을 수행한다면?

</aside>

```c
// case 1
int *p;
*p + 3;
*p = 3;

// case 2
int *p = 0x1000;
*p + 3;
*p = 3;
```

- 1번 케이스에서는 포인터가 참조하고 있는 객체가 없다.
    - 0이나 쓰레기 값으로 초기화 될 것이라 예상은 할 수 있다.
- 2번 케이스에서는 0x1000이라는 임의의 값을 참조하게 만들었다.
    - 2번 케이스가 미정의 행위지만, 일부 시스템 프로그래밍 시에는 의도적으로 이와 같은 코드를 작성하기도 한다.
    - 미리 정의되어 있는 특정한 주소가 특정 하드웨어와 연결되어 해당 주소를 읽거나 쓰는 것으로 하드웨어를 제어하기도 한다.
        - 이 경우에는 시스템이 위 동작을 에러처리 하지 않는다.
- 두 케이스 모두 유효한 객체를 참조하고 있지 않다.
    - 유효하지 않은 주소에 접근해 임의로 값을 읽고 수정하려는 행위는 안된다.

## 포인터와 const

- 아래 네 선언은 모두 같은 포인터 선언이 된다.
    
    ```c
    const int *pa = &a;
    const const const int *pa = &a;
    int const *pa = &a;
    const int const *pa = &a;
    ```
    
- 참조하는 타입이 `const int`라는 것은 간접 접근 연산으로 참조하고 있던 객체를 역참조했을 때, 해당 객체가 읽기 전용이라는 뜻이다.
    - 즉, 간접 접근해 해당 객체를 수정할 수 없다.
    
    ```c
    const int *pa = &a;
    *pa + 3;        // 읽기 가능 (a에 저장된 값을 읽고 + 3연산 수행)
    *pa = 3;        // error! 수정 불가능
    ```
    

### const

- 프로그래밍을 하다 보면 어떤 변수의 값이 변하지 않아야 하는 상황이 생긴다.
- 변수를 상수와 유사하게 값을 바꿀 수 없도록 만든다. (java final)

### const의 위치

```c
type-qualifier_opt type_specifier * type-qualifier_opt identifier;
```

- 위 포맷에서 볼 수 있는 것처럼 한정자는 `*` 구두점의 오른쪽에도 올 수 있다.
- `*` 구두점의 오른쪽에 `const` 한정자가 오면 **전혀 다른 의미를 갖게 된다.**
    - 해당 한정자는 참조하는 타입을 한정하는 것이 아니라 포인터 자체를 한정한다.
    - 해당 위치의 한정자는 선언의 형태인 `<declaration-specifiers> <init-declarator-list>;` 에서 `declaration-specifiers`가 아니라 `init-declarator-list`에 포함된다. (선언자)
    - 선언자에 포함되어 포인터 자체를 한정한다는 말은 **참조하는 타입이 아닌 포인터 값 자체가 읽기 전용이 된다는 의미이다.**

```c
// variable pointer to a constant value
const int *p = &a;      // 참조하는 타입 const int, 포인터는 수정 가능
*p + 3;                 // 읽기 가능
*p = 3;                 // error! 수정 불가능
p = &b;                 // 포인터 자체는 수정 가능 (참조하는 대상 수정 가능)

// constant pointer to a variable value
int *const p = &a;     // 참조하는 타입 int, 포인터는 수정 불가능
*p + 3;                 // 읽기 가능
*p = 3;                 // 수정 가능 (참조하는 타입이 const가 아님)
p = &b;                 // error! 포인터 자체를 수정할 수 없음 (참조하는 대상 수정 불가능)
```

```c
int const *p = &a;
int *const p = &a;
```

- 1번은 참조하는 타입이 const int이므로 간접 접근 시 내용을 수정할 수 없다.
- 2번은 참조 타입은 int지만, 포인터가 const이기 때문에 가리키는 대상을 바꿀 수는 없지만 간접 접근 시 내용을 수정할 수 있다.

```c
const int *const p = &a;   // 참조하는 타입 const int, 포인터 수정 불가능
*p + 3;                     // 읽기 가능
*p = 3;                     // error! 수정 불가능
p = &b;                     // error! 포인터 자체도 수정할 수 없음
```

- `*` 구두점의 왼쪽과 오른쪽에 `const` 한정자가 모두 붙으면 참조 타입과 포인터 모두 읽기 전용이 된다.

## 포인터 타입과 대입

- 동일한 타입의 포인터끼리는 대입 연산이 가능하다.

```c
// 아래 case 1와 case 2은 동일한 결과

// case 1
int a = 3, *p1, *p2;
p1 = &a;        // p1이 a를 가리킴
p2 = p1;        // p2에 p1을 대입

// case 2
int a = 3;
int *p1 = &a;   // p1이 a를 가리킴
int *p2 = p1;   // p2를 p1으로 초기화
```
![image](https://github.com/yu-heejin/language-practice/assets/96467030/e7974507-eda4-4950-83b7-af3971c9c44e)

- p1과 p2 모두 동일한 객체 a를 가리키고 있기 때문에 p1에 간접 접근해 값을 수정해도 a가 변경되며, p2에 간접 접근하여 값을 수정해도 a가 변경된다.
    - `a`, `*p1`, `*p2` 모두 같은 값을 읽게 된다.
- 서로 호환되는(compatible) 포인터 타입끼리는 대입 혹은 초기화가 가능하다.
